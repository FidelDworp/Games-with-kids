<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vectoren Animatie: Vlaggemast met Krachten</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; background-color: #f0f8ff; font-family: Arial, sans-serif; }
        canvas { border: 1px solid #ccc; background-color: #fff; }
        .controls { margin: 20px; }
        .slider-container { margin: 10px; }
        label { font-weight: bold; }
        .explanation { max-width: 600px; text-align: justify; margin: 20px; }
    </style>
</head>
<body>
    <h1>Vectoren Uitleg: Hoe Krachten Samenwerken</h1>
    <p>Gebruik de schuifregelaars om de krachten aan te passen. Zie hoe de vlaggemast buigt!</p>
    <canvas id="animationCanvas" width="900" height="600"></canvas>
    <div class="controls">
        <div class="slider-container">
            <label for="force1">Kracht 1 (0-100 daN): <span id="force1Value">50</span></label>
            <input type="range" id="force1" min="0" max="100" value="50">
        </div>
        <div class="slider-container">
            <label for="force2">Kracht 2 (0-100 daN): <span id="force2Value">50</span></label>
            <input type="range" id="force2" min="0" max="100" value="50">
        </div>
    </div>
    <div class="explanation">
        <p>De samenstelling van vectoren volgt de parallellogramregel, die gebaseerd is op de stelling van Thales toegepast op vectoren. Volgens deze regel vormen twee vectoren de zijden van een parallellogram, en de resultante vector is de diagonaal van dit parallellogram. Door de lengtes van de vectoren aan te passen met de schuifregelaars, zie je hoe de resultante verandert in grootte en richting, wat de buiging van de vlaggemast be√Ønvloedt.</p>
    </div>

    <script>
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d');
        const force1Slider = document.getElementById('force1');
        const force2Slider = document.getElementById('force2');
        const force1Value = document.getElementById('force1Value');
        const force2Value = document.getElementById('force2Value');

        // Basis instellingen
        const baseX = 300; // Midden van de canvas
        const baseY = 500; // Basis van de vlaggemast (bodem van kubus)
        const poleHeight = 300; // Totale hoogte van de vlaggemast
        const cubeSize = 100; // Grootte van de kubus basis
        const fixedY = baseY - cubeSize / 2; // Top van de kubus, waar buiging begint
        const effectiveL = poleHeight - (cubeSize / 2); // Effectieve lengte voor buiging
        const attachmentY = baseY - poleHeight + 50; // Aangrijpingspunt onder de vlag
        const segments = 20; // Aantal segmenten voor buigcurve

        // Vector richtingen (vast, maar verschillend: bv. een naar links-boven, een naar rechts-boven)
        const angle1 = -Math.PI / 6; // -30 graden (links-boven)
        const angle2 = Math.PI / 6;  // +30 graden (rechts-boven)

        // Maximale buiging (voor 100 daN resultante)
        const maxBend = 100; // Pixels buiging

        let force1 = 50;
        let force2 = 50;

        // Update sliders
        force1Slider.addEventListener('input', () => {
            force1 = parseInt(force1Slider.value);
            force1Value.textContent = force1;
            draw();
        });

        force2Slider.addEventListener('input', () => {
            force2 = parseInt(force2Slider.value);
            force2Value.textContent = force2;
            draw();
        });

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Bereken vectoren
            const vec1 = { x: force1 * Math.cos(angle1), y: force1 * Math.sin(angle1) };
            const vec2 = { x: force2 * Math.cos(angle2), y: force2 * Math.sin(angle2) };
            const resultant = { x: vec1.x + vec2.x, y: vec1.y + vec2.y };

            // Lengte van resultante
            const resultantMagnitude = Math.sqrt(resultant.x ** 2 + resultant.y ** 2);

            // Buigingsfactor (0-1)
            const bendFactor = Math.min(resultantMagnitude / 100, 1); // Max bij 100 daN
            const bendDirection = Math.atan2(resultant.y, resultant.x); // Richting van buiging
            const deltaMax = maxBend * bendFactor;

            // Teken vaste voet in kubus
            ctx.beginPath();
            ctx.moveTo(baseX, baseY);
            ctx.lineTo(baseX, fixedY);
            ctx.strokeStyle = '#808080'; // Grijs voor mast
            ctx.lineWidth = 10;
            ctx.stroke();

            // Teken transparante kubus
            ctx.globalAlpha = 0.5;
            drawCube(baseX - cubeSize / 2, baseY - cubeSize / 2, cubeSize);
            ctx.globalAlpha = 1.0;

            // Teken gebogen deel van vlaggemast
            ctx.beginPath();
            ctx.moveTo(baseX, fixedY);
            for (let i = 1; i <= segments; i++) {
                const frac = i / segments;
                const s = frac * effectiveL;
                const v = (deltaMax / (2 * Math.pow(effectiveL, 3))) * Math.pow(s, 2) * (3 * effectiveL - s);
                const px = baseX + v * Math.cos(bendDirection);
                const py = fixedY - s + v * Math.sin(bendDirection);
                ctx.lineTo(px, py);
            }
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 10;
            ctx.stroke();

            // Bereken positie top (flag)
            const sTop = effectiveL;
            const vTop = (deltaMax / (2 * Math.pow(effectiveL, 3))) * Math.pow(sTop, 2) * (3 * effectiveL - sTop);
            const flagX = baseX + vTop * Math.cos(bendDirection);
            const flagY = fixedY - sTop + vTop * Math.sin(bendDirection);

            // Bereken helling aan top voor vlag rotatie
            const dv_ds_top = (deltaMax / (2 * Math.pow(effectiveL, 3))) * (6 * effectiveL * sTop - 3 * Math.pow(sTop, 2));
            const dx_ds = dv_ds_top * Math.cos(bendDirection);
            const dy_ds = -1 + dv_ds_top * Math.sin(bendDirection);
            const tangentAngle = Math.atan2(dy_ds, dx_ds);

            // Teken Belgische vlag (geroteerd volgens helling top)
            drawBelgianFlag(flagX, flagY, tangentAngle);

            // Bereken positie aangrijpingspunt
            const sAttach = fixedY - attachmentY;
            const vAttach = (deltaMax / (2 * Math.pow(effectiveL, 3))) * Math.pow(sAttach, 2) * (3 * effectiveL - sAttach);
            const attachX = baseX + vAttach * Math.cos(bendDirection);
            const attachY = fixedY - sAttach + vAttach * Math.sin(bendDirection);
            ctx.beginPath();
            ctx.arc(attachX, attachY, 5, 0, 2 * Math.PI);
            ctx.fillStyle = 'black';
            ctx.fill();

            // Teken vectoren vanaf aangrijpingspunt
            drawVector(attachX, attachY, vec1.x * 2, vec1.y * 2, 'blue'); // Schaal voor zichtbaarheid
            drawVector(attachX, attachY, vec2.x * 2, vec2.y * 2, 'green');

            // Teken parallellogram
            drawParallelogram(attachX, attachY, vec1.x * 2, vec1.y * 2, vec2.x * 2, vec2.y * 2);

            // Teken resultante
            drawVector(attachX, attachY, resultant.x * 2, resultant.y * 2, 'red');
        }

        function drawCube(x, y, size) {
            // Voorkant
            ctx.fillStyle = '#8B4513'; // Bruin
            ctx.fillRect(x, y, size, size / 2);

            // Bovenkant
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + size / 2, y - size / 2);
            ctx.lineTo(x + size + size / 2, y - size / 2);
            ctx.lineTo(x + size, y);
            ctx.closePath();
            ctx.fillStyle = '#A0522D';
            ctx.fill();

            // Zijkant
            ctx.beginPath();
            ctx.moveTo(x + size, y);
            ctx.lineTo(x + size + size / 2, y - size / 2);
            ctx.lineTo(x + size + size / 2, y + size / 2 - size / 2);
            ctx.lineTo(x + size, y + size / 2);
            ctx.closePath();
            ctx.fillStyle = '#A0522D';
            ctx.fill();
        }

        function drawBelgianFlag(x, y, rotation) {
            const flagWidth = 60;
            const flagHeight = 40;
            const stripeWidth = flagWidth / 3;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation + Math.PI / 2); // Pas rotatie toe om vlag te alignen met masttop richting

            // Zwarte strook (links, aan de stok)
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, stripeWidth, flagHeight);

            // Gele strook (midden)
            ctx.fillStyle = 'yellow';
            ctx.fillRect(stripeWidth, 0, stripeWidth, flagHeight);

            // Rode strook (rechts)
            ctx.fillStyle = 'red';
            ctx.fillRect(2 * stripeWidth, 0, stripeWidth, flagHeight);

            // Rand om de vlag
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, flagWidth, flagHeight);

            ctx.restore();
        }

        function drawVector(startX, startY, dx, dy, color) {
            const headlen = 10;
            const angle = Math.atan2(dy, dx);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX + dx, startY + dy);
            ctx.lineTo(startX + dx - headlen * Math.cos(angle - Math.PI / 6), startY + dy - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(startX + dx, startY + dy);
            ctx.lineTo(startX + dx - headlen * Math.cos(angle + Math.PI / 6), startY + dy - headlen * Math.sin(angle + Math.PI / 6));
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function drawParallelogram(startX, startY, dx1, dy1, dx2, dy2) {
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX + dx1, startY + dy1);
            ctx.lineTo(startX + dx1 + dx2, startY + dy1 + dy2);
            ctx.lineTo(startX + dx2, startY + dy2);
            ctx.closePath();
            ctx.strokeStyle = 'purple';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Initial draw
        draw();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vectoren Animatie: Vlaggemast met Krachten</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; background-color: #f0f8ff; font-family: Arial, sans-serif; }
        canvas { border: 1px solid #ccc; background-color: #fff; }
        .controls { margin: 20px; }
        .slider-container { margin: 10px; }
        label { font-weight: bold; }
        .explanation { max-width: 600px; text-align: justify; margin: 20px; }
    </style>
</head>
<body>
    <h1>Vectoren Uitleg: Hoe Krachten Samenwerken</h1>
    <p>Gebruik de schuifregelaars om de krachten aan te passen. Zie hoe de vlaggemast buigt!</p>
    <canvas id="animationCanvas" width="600" height="600"></canvas>
    <div class="controls">
        <div class="slider-container">
            <label for="force1">Kracht 1 (0-100 daN): <span id="force1Value">50</span></label>
            <input type="range" id="force1" min="0" max="100" value="50">
        </div>
        <div class="slider-container">
            <label for="force2">Kracht 2 (0-100 daN): <span id="force2Value">50</span></label>
            <input type="range" id="force2" min="0" max="100" value="50">
        </div>
    </div>
    <div class="explanation">
        <p>De samenstelling van vectoren volgt de parallellogramregel, die gebaseerd is op de stelling van Thales toegepast op vectoren. Volgens deze regel vormen twee vectoren de zijden van een parallellogram, en de resultante vector is de diagonaal van dit parallellogram. Door de lengtes van de vectoren aan te passen met de schuifregelaars, zie je hoe de resultante verandert in grootte en richting, wat de buiging van de vlaggemast beïnvloedt.</p>
    </div>

    <script>
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d');
        const force1Slider = document.getElementById('force1');
        const force2Slider = document.getElementById('force2');
        const force1Value = document.getElementById('force1Value');
        const force2Value = document.getElementById('force2Value');

        // Basis instellingen
        const baseX = 300; // Midden van de canvas
        const baseY = 500; // Basis van de vlaggemast
        const poleHeight = 300; // Hoogte van de vlaggemast
        const attachmentY = baseY - poleHeight + 50; // Aangrijpingspunt onder de vlag
        const cubeSize = 100; // Grootte van de kubus basis

        // Vector richtingen (vast, maar verschillend: bv. een naar links-boven, een naar rechts-boven)
        const angle1 = -Math.PI / 6; // -30 graden (links-boven)
        const angle2 = Math.PI / 6;  // +30 graden (rechts-boven)

        // Maximale buiging (voor 100 daN resultante)
        const maxBend = 100; // Pixels buiging

        let force1 = 50;
        let force2 = 50;

        // Update sliders
        force1Slider.addEventListener('input', () => {
            force1 = parseInt(force1Slider.value);
            force1Value.textContent = force1;
            draw();
        });

        force2Slider.addEventListener('input', () => {
            force2 = parseInt(force2Slider.value);
            force2Value.textContent = force2;
            draw();
        });

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Teken transparante kubus basis
            ctx.globalAlpha = 0.5;
            drawCube(baseX - cubeSize / 2, baseY - cubeSize / 2, cubeSize);
            ctx.globalAlpha = 1.0;

            // Bereken vectoren
            const vec1 = { x: force1 * Math.cos(angle1), y: force1 * Math.sin(angle1) };
            const vec2 = { x: force2 * Math.cos(angle2), y: force2 * Math.sin(angle2) };
            const resultant = { x: vec1.x + vec2.x, y: vec1.y + vec2.y };

            // Lengte van resultante
            const resultantMagnitude = Math.sqrt(resultant.x ** 2 + resultant.y ** 2);

            // Buigingsfactor (0-1)
            const bendFactor = Math.min(resultantMagnitude / 100, 1); // Max bij 100 daN
            const bendDirection = Math.atan2(resultant.y, resultant.x); // Richting van buiging

            // Teken gebogen vlaggemast (voet vast, buigt erboven)
            drawBentPole(baseX, baseY, poleHeight, bendFactor, bendDirection);

            // Teken Belgische vlag bovenaan (meebewegend met top)
            const flagX = baseX + (maxBend * bendFactor) * Math.cos(bendDirection);
            const flagY = baseY - poleHeight + (maxBend * bendFactor) * Math.sin(bendDirection);
            drawBelgianFlag(flagX, flagY);

            // Teken aangrijpingspunt (geïnterpoleerd op de buiging)
            const attachRatio = (baseY - attachmentY) / poleHeight; // Proportie vanaf basis (0 basis, 1 top)
            const attachX = baseX + (maxBend * bendFactor * attachRatio) * Math.cos(bendDirection);
            const attachY = attachmentY + (maxBend * bendFactor * attachRatio) * Math.sin(bendDirection);
            ctx.beginPath();
            ctx.arc(attachX, attachY, 5, 0, 2 * Math.PI);
            ctx.fillStyle = 'black';
            ctx.fill();

            // Teken vectoren vanaf aangrijpingspunt
            drawVector(attachX, attachY, vec1.x * 2, vec1.y * 2, 'blue'); // Schaal voor zichtbaarheid
            drawVector(attachX, attachY, vec2.x * 2, vec2.y * 2, 'green');

            // Teken parallellogram
            drawParallelogram(attachX, attachY, vec1.x * 2, vec1.y * 2, vec2.x * 2, vec2.y * 2);

            // Teken resultante
            drawVector(attachX, attachY, resultant.x * 2, resultant.y * 2, 'red');
        }

        function drawCube(x, y, size) {
            // Voorkant
            ctx.fillStyle = '#8B4513'; // Bruin
            ctx.fillRect(x, y, size, size / 2);

            // Bovenkant
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + size / 2, y - size / 2);
            ctx.lineTo(x + size + size / 2, y - size / 2);
            ctx.lineTo(x + size, y);
            ctx.closePath();
            ctx.fillStyle = '#A0522D';
            ctx.fill();

            // Zijkant
            ctx.beginPath();
            ctx.moveTo(x + size, y);
            ctx.lineTo(x + size + size / 2, y - size / 2);
            ctx.lineTo(x + size + size / 2, y + size / 2 - size / 2);
            ctx.lineTo(x + size, y + size / 2);
            ctx.closePath();
            ctx.fillStyle = '#A0522D';
            ctx.fill();
        }

        function drawBentPole(startX, startY, height, bendFactor, direction) {
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            const controlX = startX + (maxBend * bendFactor) * Math.cos(direction) / 2;
            const controlY = startY - height / 2;
            const endX = startX + (maxBend * bendFactor) * Math.cos(direction);
            const endY = startY - height + (maxBend * bendFactor) * Math.sin(direction);
            ctx.quadraticCurveTo(controlX, controlY, endX, endY);
            ctx.strokeStyle = '#808080'; // Grijs voor mast
            ctx.lineWidth = 10;
            ctx.stroke();
        }

        function drawBelgianFlag(x, y) {
            const flagWidth = 60;
            const flagHeight = 40;
            const stripeWidth = flagWidth / 3;

            // Zwarte strook (links, aan de stok)
            ctx.fillStyle = 'black';
            ctx.fillRect(x, y, stripeWidth, flagHeight);

            // Gele strook (midden)
            ctx.fillStyle = 'yellow';
            ctx.fillRect(x + stripeWidth, y, stripeWidth, flagHeight);

            // Rode strook (rechts)
            ctx.fillStyle = 'red';
            ctx.fillRect(x + 2 * stripeWidth, y, stripeWidth, flagHeight);

            // Rand om de vlag
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, flagWidth, flagHeight);
        }

        function drawVector(startX, startY, dx, dy, color) {
            const headlen = 10;
            const angle = Math.atan2(dy, dx);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX + dx, startY + dy);
            ctx.lineTo(startX + dx - headlen * Math.cos(angle - Math.PI / 6), startY + dy - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(startX + dx, startY + dy);
            ctx.lineTo(startX + dx - headlen * Math.cos(angle + Math.PI / 6), startY + dy - headlen * Math.sin(angle + Math.PI / 6));
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function drawParallelogram(startX, startY, dx1, dy1, dx2, dy2) {
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX + dx1, startY + dy1);
            ctx.lineTo(startX + dx1 + dx2, startY + dy1 + dy2);
            ctx.lineTo(startX + dx2, startY + dy2);
            ctx.closePath();
            ctx.strokeStyle = 'purple';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Initial draw
        draw();
    </script>
</body>
</html>
